/***
         _______  ______  ____    ______
        | ____\ \/ /  _ \/ ___|  / /___ \
        |  _|  \  /| |_) \___ \ / /  __) |
        | |___ /  \|  __/ ___) / /  / __/
        |_____/_/\_\_|   |____/_/  |_____|

       Teclado PS/2 externo para Expert XP800
       Danjovic 2021 
       05 april 2021 - basic release
*/


#include <util/delay.h>


#define BIT_DLY_9600   103
#define BIT_DLY_19200  51
#define BIT_DLY_38400  25
#define BIT_DLY_57600  17
#define BIT_DLY_115200 8
#define BIT_DELAY      BIT_DLY_9600

#define DDRUART        DDRB
#define PORTUART       PORTB
#define BITUART        4


#include "msxKeyboardMatrix.h"
#include "ps2keyMap.h"
//#include "myPS2.h"             // pin definition on the file
#include <ps2.h>
PS2 kbd(9, 8);



//       _      __ _      _ _   _
//    __| |___ / _(_)_ _ (_) |_(_)___ _ _  ___
//   / _` / -_)  _| | ' \| |  _| / _ \ ' \(_-<
//   \__,_\___|_| |_|_||_|_|\__|_\___/_||_/__/
//
#define Keymap_Size 16  // 16 up to lines of keys for Hotbit 

//                 _      _    _
//   __ ____ _ _ _(_)__ _| |__| |___ ___
//   \ V / _` | '_| / _` | '_ \ / -_|_-<
//    \_/\__,_|_| |_\__,_|_.__/_\___/__/
//

static volatile uint8_t cc = 5;
volatile  uint8_t Keymap[Keymap_Size];
bool EXT = false;
bool BRK = false;
bool SHIFT = false;
bool LAST_SHIFT = false;



//    _     _                         _
//   (_)_ _| |_ ___ _ _ _ _ _  _ _ __| |_ ___
//   | | ' \  _/ -_) '_| '_| || | '_ \  _(_-<
//   |_|_||_\__\___|_| |_|  \_,_| .__/\__/__/
//                              |_|



/*
  ISR (PCINT1_vect) {
  DDRD = Keymap [PINC & 0x0f];
  }
*/



volatile uint8_t zero = 0;
ISR (PCINT1_vect, ISR_NAKED) {
  asm volatile (                     // 7-9  até aqui
    "in __zero_reg__,__SREG__ \n\t"  // 1 Salva registrador de Status
    "out %[_GPIOR1],r26\n\t"         // 1 salva registro em 1 ciclo
    "out %[_GPIOR2],r27\n\t"         // 1 salva registro em 1 ciclo
    
    "ldi r27,hi8(Keymap)\n\t"        // 1 Ponteiro X = endereço de Keymap  
    "in r26,%[_PINC] \n\t"           // 1
    "subi r26, lo8(-(Keymap)) \n\t"  // 1 
    "ld 26,X \n\t"                   // 2 lê coluna correspondente do mapa de teclas
    "out %[_DDRD] ,r26 \n\t"         // 1 escreve na porta B da PPI
                                     // até aqui 16 instruções (1us @16Mhz)
    "in r26, %[_GPIOR1] \n\t"
    "in r27, %[_GPIOR2] \n\t"

    "sbi %[_PCIFR],1 \n\t"           // reset interrupt bit

    "out __SREG__,__zero_reg__ \n\t" // restaura registrador de Status
    "lds __zero_reg__, zero \n\t"
    "reti \n\t"

    ::[_PINC] "I" (_SFR_IO_ADDR(PINC)  ),
    [_DDRD]   "I" (_SFR_IO_ADDR(DDRD)  ),
    [_PORTB]  "I" (_SFR_IO_ADDR(PORTB) ),    
    [_GPIOR1] "I" (_SFR_IO_ADDR(GPIOR1)),
    [_GPIOR2] "I" (_SFR_IO_ADDR(GPIOR2)), 
    [_PCIFR]  "I" (_SFR_IO_ADDR(PCIFR) )
    );

}


//    ___      _
//   / __| ___| |_ _  _ _ __
//   \__ \/ -_)  _| || | '_ \
//   |___/\___|\__|\_,_| .__/
//                     |_|


void setup() {
  // Configure I/O ports
  //  DDRB = 0;     // all pins as inputs
  //  PORTB = 0x03; // pullups on PS/2 pins
  //  mySerial.begin(9600);

  DDRB = (1 << 5);   // pb5 all pins as inputs
  PORTB = 0x03; // pullups on PS/2 pins

  DDRC =  0xf0; // unused pins as outputs
  PORTC = 0x00; // no pullups

  DDRD =  0x00; // all matrix columns pins pins as inputs
  PORTD = 0x00; // all matrix columns pins open (unactive for MSX)

  initsoftSend();
  debug("init\n");


  initalizeKeyboard();
  clearMatrix();

  // Configure Interrupts
  PCICR  = (1 << PCIE1); // enable pin change interrupts on port C
  PCIFR |= (1 << PCIF1); // clear any pending interrupt
  PCMSK1 = 0x0f;        // any pin on port C can trigger an interrupt
  TIMSK0 = 0;           // disable Timer 0 interrupts generated by Arduino

  sei();                // enable interrupts

}



//    _                   ____
//   | |   ___  ___ _ __ / /\ \ 
//   | |__/ _ \/ _ \ '_ \ |  | |
//   |____\___/\___/ .__/ |  | |
//                 |_|   \_\/_/


void loop() {
  uint8_t code, m;



  for (;;) { /* ever */
    /* Get a keycode from the keyboard and convert and update Keyboard Map */
    code = kbd.read();  debug ("["); printHex (code); debug ("]");

    // Clean keyboard matrix on buffer overflows

    if ( (code == 0x00) | (code == 0xff) ) {  // Error codes
      debug ("!\n");
      clearMatrix();

    } else { // not error codes


      if (code == 0xE0) {
        EXT = true; //Serial.println ("extend");
      } else if (code == 0xF0) {
        BRK = true; //Serial.println ("release");
      } else {
        if (EXT == true) { // extended keys
          EXT = false;
          switch (code) {
            case _PS2_UP_ARROW:     m = _UP      ; break;
            case _PS2_DOWN_ARROW:   m = _DOWN    ; break;
            case _PS2_LEFT_ARROW:   m = _LEFT    ; break;
            case _PS2_RIGHT_ARROW:  m = _RIGHT   ; break;
            case _PS2_RIGHT_ALT:    m = _CODE    ; break;
            case _PS2_RIGHT_CTRL:   m = _CONTROL ; break;
            case _PS2_LEFT_GUI:     m = _SPACE   ; break;
            case _PS2_RIGHT_GUI:    m = _SPACE   ; break;
            case _PS2_KPSLASH:      m = _KPSLASH ; break;
            case _PS2_KPENTER:      m = _ENTER   ; break;
            case _PS2_END:          m = _STOP    ; break;
            case _PS2_HOME:         m = _HOME    ; break;
            case _PS2_INSERT:       m = _INSERT  ; break;
            case _PS2_DELETE:       m = _DELETE  ; break;

            default:                m = _NONE    ; break;
          } // switch
        } else { // normal set
          if (code == 0x83) code = 0x63; // manter tabela menor que 128 caracteres

          if (code < 128) {
            if (SHIFT == false) m = pgm_read_byte(PS2Keymap_Normal + code);
            else m = pgm_read_byte(PS2Keymap_Shifted + code);
          } else {
            m = _NONE;
          }
        }  // end of normal set


        updateMatrix(m);
        debug ("<"); printHex (m); debug (">\n");        
        // printMatrix();
      }

    } // end of "not error codes"
  }


}//  loop()




//     __              _   _
//    / _|_  _ _ _  __| |_(_)___ _ _  ___
//   |  _| || | ' \/ _|  _| / _ \ ' \(_-<
//   |_|  \_,_|_||_\__|\__|_\___/_||_/__/
//

//
// Initialize Keyboard
//
void initalizeKeyboard()
{
  char ack;
  kbd.write(0xff);  // send reset code
  ack = kbd.read();  // byte, kbd does self test
  ack = kbd.read();  // another ack when self test is done
}


//
// Activate the key addressed by m
//
void clearBit(uint8_t m) {
  uint8_t col = m & 0x07 ;
  uint8_t lin = (m >> 3) & 0x0f;
  softSendByte('T');
  
//  Keymap[0] &= 0xfe;
    Keymap[lin] &= ~(1 << col);
  if ( (m & 0x80) != 0) Keymap[LIN_SHIFT] &= ~(1 << COL_SHIFT);
  softSendByte('\\');
}


//
// Deactivate the key addressed by m
//
void setBit(uint8_t m) {
  uint8_t col = m & 0x07 ;
  uint8_t lin = (m >> 3) & 0x0f;
  softSendByte('_');
  
//   Keymap[0] |= 1;
  
  Keymap[lin] |= (1 << col);

  // Activate SHIFT bit accordingly
  if ( (m & 0x80) != 0) Keymap[LIN_SHIFT] |= (1 << COL_SHIFT);
  softSendByte('/');
  
}




//
// Clear the Keyboard Matrix
//
void clearMatrix()
{
  uint8_t i;
  for (i = 0; i < Keymap_Size; i++) // clear keymap
    Keymap[i] = 0x00;
}



//
// Update the Keyboard Matrix based on a map code for a row and a line
//
//   MSX keyboard matrix map codes
//    7     6     5     4     3     2     1     0    BIT
// +-----------------------------------------------+
// |SHIFT|       ROW [0..10]     |    COL[0..7]    |
// +-----------------------------------------------+


void updateMatrix(char k) {
  if (BRK == true) { // break code
    BRK = false;
    if (k == _SHIFT) SHIFT = 0; // Reset SHIFT flag on break code of any shift
    clearBit(k); //setBit(k);
  } else {  // make code
    if (k == _SHIFT) SHIFT = 1; // Set SHIFT flag on make code of any shift
    setBit(k); //clearBit(k);
  }
}


void initsoftSend() {
  DDRUART |= (1 << BITUART);
  PORTUART |= (1 << BITUART);
}

void debug( char *s) {
  char *ptr = s;

  while (*ptr) {
    if (*ptr == '\n') softSendByte ('\r');
    softSendByte( *ptr);
    ptr++;
  }


}
void softSendByte (uint8_t dado) {
  // 9600 bauds
  uint16_t shiftRegister;
  uint8_t i, temp;
  // 15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
  shiftRegister  = 0xff00 | (uint16_t)dado;  // 1  1  1  1  1  1  1  1 [         dado         ]
  shiftRegister <<= 1;                       // 1  1  1  1  1  1  1 [         dado         ] 0

  for (i = 0; i < 12; i++) { // 2 stop bits
    if (shiftRegister & 1)  PORTUART |= (1 << BITUART); else PORTUART &= ~(1 << BITUART);
    shiftRegister >>= 1;
    _delay_us (BIT_DELAY);
  }
}




void printMatrix() {
  //  debug("\e[H");
  for (uint8_t i = 0; i < 15; i++) {

    uint8_t temp = Keymap[i];

    uint8_t linha = 0;
    if (temp & (1 << 0)) linha |= (1 << 1) ; // Reorder bits.
    if (temp & (1 << 1)) linha |= (1 << 6) ;
    if (temp & (1 << 2)) linha |= (1 << 3) ;
    if (temp & (1 << 3)) linha |= (1 << 7) ;
    if (temp & (1 << 4)) linha |= (1 << 5) ;
    if (temp & (1 << 5)) linha |= (1 << 0) ;
    if (temp & (1 << 6)) linha |= (1 << 2) ;
    if (temp & (1 << 7)) linha |= (1 << 4) ;


    printBin(linha);
    debug("\n");

  }

  debug("\n");

}

void printHex ( uint8_t h) {
  char table[16] = {"0123456789ABCDEF"};
  uint8_t nibble = h >> 4;
  softSendByte (table [ nibble ] );
  softSendByte (table [ h & 0x0f]  );


}

void printBin ( uint8_t l) {
  uint8_t mask = 0x80;
  for (uint8_t j = 0; j < 8; j++) {
    if (l & mask) softSendByte ('1'); else softSendByte ('0');
    softSendByte (' ');
    mask >>= 1;
  }
}
